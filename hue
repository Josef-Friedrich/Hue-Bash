#! /bin/sh

########################################################################
# Configuration
########################################################################

IP="192.168.2.31"

USERNAME="joseffriedrich"

INSTALLATION_PATH="/root/hue"

PIDFILE="$HOME/.hue-bash_temp"

SCENES_PATH="$INSTALLATION_PATH/scenes"

DEFAULT_SCENE="random"

ALL_LIGHTS="1,2,3,7,8,9"

##
# Hue Colors
##

_RED="--hue 0"

_YELLOW="--hue 12750"

_GREEN="--hue 25500"

_WHITE="--hue 36210"

_BLUE="--hue 46920"

_CYAN="--hue 56100"

_RED2="--hue 65535"

##
# Light recipes
##

_DEFAULT="--ct 369 --bri 254"

_RELAX="--ct 443 --bri 173"

_CONCENTRATE="--ct 233 --bri 219"

_ENERGIZE="--ct 156 --bri 203"

_READING="--ct 346 --bri 240"

# Groups

_BEDROOM="1,2,3"

_LIVING="6,7,8"

########################################################################
# Checks
########################################################################

if [ ! -f $PIDFILE ]; then
  touch $PIDFILE
  chmod 777 $PIDFILE
fi

########################################################################
# Options
########################################################################

while getopts ":djts" OPT; do

  case $OPT in
    d)
      DEBUG=1
      echo "debug mode" >&2
      ;;

    j)
      JQDEBUG=1
      echo "debug mode with jq" >&2
      ;;

    s)
      JSONDEBUG=1
      echo "json debug mode" >&2
      ;;

    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;

    :)
      echo "Option -$OPTARG requires an argument." >&2
      exit 1
      ;;

  esac
done

shift $((OPTIND-1))

########################################################################
# Library functions
########################################################################

##
# Loop function.
##
hue_loop() {
  (
    while true; do
      eval "$*"
    done
  ) &
  echo $! >> $PIDFILE
}

##
# Random range function.
#
# - $1 = RANGE (3:7)
##
hue_range() {
  local START=${1%%:*}
  local END=${1#*:}

  local END=$((END + 1))

  local RANGE=$((END - START))

  local RANDOM=$(tr -cd 0-9 < /dev/urandom | head -c 6)

  local NUMBER_IN_RANGE=$((RANDOM % RANGE))

  echo $((NUMBER_IN_RANGE + START))
}

##
# Sleep as long as transitiontime.
#
# - $1 = TIME
##
hue_sleep() {
  local TIME=$1
  INTEGER=$(echo -n $TIME | head -c -1 )
  COMMA=$(echo -n $TIME | tail -c -1 )
  sleep "$INTEGER.$COMMA"
}

########################################################################
# Scenes
########################################################################

##
# Scene: One color.
#
# - $1 = HUE
##
hue_scene_one_color() {
  hue_stop
  hue_set all --hue $1 --sat 255 --bri 255
}

########################################################################

##
# Scene: Recipe
#
# - $1 = RECIPE
##
hue_scene_recipe() {

  hue_stop

  while true ; do
    case "$1" in

      -c|--concentrate)
        hue_set all --ct 233 --bri 219
        break
        ;;

      -d|--default)
        hue_set all --ct 369 --bri 254
        break
        ;;

      -e|--energize)
        hue_set all --ct 156 --bri 203
        break
        ;;

      -h|--help)
        hue_scene_recipe_help
        break
        ;;

      -R|--reading)
        hue_set all --ct 346 --bri 240
        break
        ;;

      -r|--relax)
        hue_set all --ct 443 --bri 173
        break
        ;;

      *)
        hue_scene_recipe_help
        break
        ;;

    esac
  done
}

hue_scene_recipe_help() {
  echo "Usage: hue recipe <option>

The options are (only one option is possible):
  -c  --concentrate
  -d  --default
  -e  --energize
  -h  --help
  -R  --reading
  -r  --relax

This scene command shows white colors in different color temperatures.
All lights displaying the same color temperature.

| COLD ->
  -> energize (156)
  -> concentrate (233)
  -> reading (346)
  -> default (369)
  -> relax (443)
-> WARM |

The numbers in parentheses are Mired color temperature values.
"
}

########################################################################

##
# Scene: Random breath.
##
hue_scene_random_breath() {

  hue_stop

  while true ; do
    case "$1" in

      -l|--lights)
        local LIGHTS=$2
        shift 2
        ;;

      -h|--hue-range)
        local HUE_RANGE=$2
        shift 2
        ;;

      -t|--time-range)
        local TIME_RANGE=$2
        shift 2
        ;;

      -b|--bri-range|--brightness-range)
        local BRI_RANGE=$2
        shift 2
        ;;

      *)
        break
        ;;
    esac
  done

  #
  # Default values.
  #
  if [ -z $LIGHTS ]; then

    if [ -n $ALL_LIGHTS ]; then
      LIGHTS=$ALL_LIGHTS
    else
      echo "Usage: hue random-breath --lights 1,2,3 --hue-range 52000:58000 --time-range 5:15 --brightness-range 50:150"
      exit 1
    fi
  fi

  if [ -z $HUE_RANGE ]; then
    local HUE_RANGE='52000:58000'
  fi

  if [ -z $TIME_RANGE ]; then
    local TIME_RANGE='15:25'
  fi

  if [ -z $BRI_RANGE ]; then
    local BRI_RANGE='50:255'
  fi

  LIGHTS=$(echo $LIGHTS | tr "," "\n")

  for LIGHT in $LIGHTS ; do
    hue_loop _hue_scene_random_breath $LIGHT $HUE_RANGE $TIME_RANGE $BRI_RANGE
  done
}

##
# Helper function for random breath scene.
#
# - $1 = LIGHT
# - $2 = HUE_RANGE
# - $3 = TIME_RANGE
# - $4 = BRI_RANGE
##
_hue_scene_random_breath() {
  local TRANSTIME=$(hue_range $3)
  local BRI_START=${4%%:*}
  local BRI_END=${4#*:}

  hue_set_transit $1 $TRANSTIME --hue $(hue_range $2) --bri $BRI_END --sat 255
  sleep 0.2
  hue_set_transit $1 $TRANSTIME --bri $BRI_START
  sleep 0.2
}

########################################################################

##
# Scene: All lights change at the same time the color in a given sequence.
##
hue_scene_color_sequence() {

  hue_stop

  while true ; do
    case "$1" in

      -h|--hues|--huesequence)
        local HUE_SEQUENCE=$2
        shift 2
        ;;

      -s|--sleeptime)
        local SLEEP_TIME=$2
        shift 2
        ;;

      -t|--transitiontime)
        local TRANSITION_TIME=$2
        shift 2
        ;;

      -b|--bri|--brightness)
        local BRIGHTNESS=$2
        shift 2
        ;;

      *)
        break
        ;;
    esac
  done

  #
  # Default values.
  #
  if [ -z $HUE_SEQUENCE ]; then
    local HUE_SEQUENCE='0,12750,25500,46920,56100'
  fi

  if [ -z $SLEEP_TIME ]; then
    local SLEEP_TIME='50'
  fi

  if [ -z $TRANSITION_TIME ]; then
    local TRANSITION_TIME='5'
  fi

  if [ -z $BRIGHTNESS ]; then
    local BRIGHTNESS='255'
  fi

  hue_loop _hue_scene_color_sequence $HUE_SEQUENCE $SLEEP_TIME $TRANSITION_TIME $BRIGHTNESS
}

##
# - $1 = HUE_SEQUENCE
# - $2 = SLEEP_TIME
# - $3 = TRANSITION_TIME
# - $4 = BRIGHTNESS
##
_hue_scene_color_sequence() {
  HUE_SEQUENCE=$(echo $1 | tr "," "\n")

  for HUE in $HUE_SEQUENCE ; do
    hue_set all --sat 255 --hue $HUE -t $3 --bri $4
    hue_sleep $2
  done
}

########################################################################

##
# Scene: Switch between two colors.
##
hue_scene_two_color_switch() {

  hue_stop

  while true ; do
    case "$1" in

      -l1|--lights1)
        local LIGHTS1=$2
        shift 2
        ;;

      -l2|--lights2)
        local LIGHTS2=$2
        shift 2
        ;;

      -c1|color1)
        local COLOR1=$2
        shift 2
        ;;

      -c2|color2)
        local COLOR2=$2
        shift 2
        ;;

      -s|switchtime)
        local SWITCH_TIME=$2
        shift 2
        ;;

      *)
        break
        ;;
    esac
  done

  #
  # Default values.
  #
  if [ -z $LIGHTS1 ] || [ -z $LIGHTS2 ] ; then
    echo "Usage: hue two-color-switch --lights1 1,2 --lights2 3,4"
    exit 1
  fi

  if [ -z $COLOR1 ]; then
    local COLOR1='0'
  fi

  if [ -z $COLOR2 ]; then
    local COLOR2='46920'
  fi

  if [ -z $SWITCH_TIME ]; then
    local SWITCH_TIME='20'
  fi

  hue_set all sat 255
  hue_set all bri 255

  hue_loop _hue_scene_two_color_switch $LIGHTS1 $LIGHTS2 $COLOR1 $COLOR2 $SWITCH_TIME
}

##
# - 1$ = LIGHTS1
# - 2$ = LIGHTS2
# - 3$ = COLOR1
# - 4$ = COLOR2
# - 5$ = SWITCH_TIME
##
_hue_scene_two_color_switch() {

  hue_set $1 --hue $3 -t 5
  hue_set $2 --hue $4 -t 5
  hue_sleep $5

  hue_set $2 --hue $3 -t 5
  hue_set $1 --hue $4 -t 5
  hue_sleep $5
}

########################################################################
# Scene functions
########################################################################

_hue_scene_get_random() {
  cat $INSTALLATION_PATH/random-scenes.conf | grep -v '^$' | grep -v '#' | sort -R | head -n 1
}

hue_scene_random() {
  hue_stop
  eval $(_hue_scene_get_random)
}

##
# Show available scenes.
##
hue_scene_info() {
  echo "Available scenes:"

  for SCENE in $(find $SCENES_PATH -name "*.scene"); do

    local TOKEN=$(echo $SCENE | sed 's:.*/\(.*\).scene:\1:')
    echo "  -> $TOKEN"

  done
}

##
# Execute scene.
#
# - $1 = SCENE_TOKEN
##
hue_scene_execute() {
  local SCENE="$SCENES_PATH/$1.scene"

  hue_stop

  if [ -f "$SCENE" ]; then
    $SCENE
  else
    local DEFAULT_SCENE="$SCENES_PATH/$DEFAULT_SCENE.scene"

    $DEFAULT_SCENE
  fi
}

##
# Switch for scene functions.
##
hue_scene_switch() {

  case "$1" in

    execute)
      hue_scene_execute $2
      ;;

    info)
      hue_scene_info
      ;;

    stop)
      hue_stop
      ;;

    reset)
      hue_reset
      ;;

    *)
      hue_help
      ;;

  esac
}

##
# Print out a short help text.
##
hue_help() {
  echo "Usage: hue <command>
  - help
  - set <lights> <attributes>
  - get <lights>
  - alert <lights>
  - scene
    - execute <scene>: Execute scene
    - info: Show available scenes
    - stop: Stop scene


One color scenes:

  one-color
  recipe

Multi color scenes:

  color-sequence
  random-breath
  two-color-switch

 "
}

##
# Execute the http call over curl.
#
# - $1 = HTTP_REQUEST: PUT, GET
# - $2 = PATH:
# - $3 = JSON:
##
hue_call() {
  if [ -n "$3" ]; then
    local DATA="--data $3"

    if [ $JSONDEBUG ]; then
      echo $3
    fi
  fi

  curl --silent --request $1 $DATA http://$IP/api/$USERNAME/$2 | hue_output
}

##
# Stop all hue processes.
##
hue_stop() {

  for PID in $(cat $PIDFILE); do
    kill $PID > /dev/null 2>&1
  done

  > $PIDFILE

  #pkill hue
}

##
# Kill all hue process.
##
hue_kill() {
  hue_reset
  pkill hue
}

##
# Stop all hue processes and reset to default color.
##
hue_reset() {
  hue_stop
  hue_set all $_DEFAULT
}

##
# Print out the ip adresse and the hue username.
##
hue_debug() {
  echo "IP: $IP"
  echo "USERNAME: $USERNAME"
}

##
# Set light state.
#
# - $1 = LIGHTS
# - $@ = LIGHT_ATTRIBUTES
##
hue_set() {
  local LIGHTS="$1"
  shift

  VALUES=""

  while true ; do
    case "$1" in

      --on)
        VALUES="$VALUES,\"on\":true"
        shift 1
        ;;

      --off)
        VALUES="$VALUES,\"on\":false"
        shift 1
        ;;

      -b|--bri)
        VALUES="$VALUES,\"bri\":$2"
        shift 2
        ;;

      -h|--hue)
        VALUES="$VALUES,\"hue\":$2"
        shift 2
        ;;

      -s|--sat)
        VALUES="$VALUES,\"sat\":$2"
        shift 2
        ;;

      -x)
        local X=$2
        shift 2
        ;;

      -y)
        local Y=$2
        shift 2
        ;;

      -c|--ct)
        VALUES="$VALUES,\"ct\":$2"
        shift 2
        ;;

      -a|--alert)
        VALUES="$VALUES,\"alert\":\"$2\""
        shift 2
        ;;

      -e|--effect)
        VALUES="$VALUES,\"effect\":\"$2\""
        shift 2
        ;;

      -t|--transitiontime)
        VALUES="$VALUES,\"transitiontime\":$2"
        shift 2
        ;;

      *)
        hue_set_help
        break
        ;;
    esac
  done

  if [ $X ] && [ $Y ]; then
    VALUES="$VALUES,\"xy\":[$X,$Y]"
  fi

  VALUES=$(echo -n $VALUES | tail -c +2)

  local JSON="{$VALUES}"

  if [ "$LIGHTS" = "all" ]; then

    hue_call PUT groups/0/action $JSON

  else

    local LIGHTS=$(echo "$LIGHTS" | tr "," "\n")

    for LIGHT in $LIGHTS; do
      hue_call PUT lights/$LIGHT/state "$JSON"
    done

  fi
}

hue_set_help() {
  echo "Usage: hue set <options>

      --on                On state of the light.
      --off               Off state of the light.
  -b  --bri               The brightness value to set the light to.
  -h  --hue               The hue value to set light to.
  -s  --sat               Saturation of the light.
  -x                      The x coordinates in CIE color space.
  -y                      The y coordinates in CIE color space.
  -c  --ct                The Mired Color temperature of the light.
  -a  --alert             The alert effect, is a temporary change to the
                          bulb’s state.
  -e  --effect            The dynamic effect of the light. Currently
                          “none” and “colorloop” are supported.
  -t  --transitiontime    The duration of the transition from the
                          light’s current state to the new state.
"
}

##
# Set light state with tokens.
#
# - $1 = LIGHTS
# - $2 = TOKEN
##
hue_set_token() {
  local LIGHTS="$1"
  local TOKEN="$2"

  hue_set $LIGHTS $TOKEN
}

##
# Set light state with transistion time an sleep.
#
# $1 = LIGHTS:
# $2 = TRANSITIONTIME: 1 = 1/10s, 10 = 1s
##
hue_set_transit() {
  local LIGHTS="$1"
  local TRANSITIONTIME="$2"
  shift 2

  hue_set $LIGHTS --transitiontime $TRANSITIONTIME $@
  hue_sleep $TRANSITIONTIME
}

##
# Get the state of the lights.
#
# - $1 = LIGHTS
##
hue_get() {
  local LIGHTS="$1"
  shift

  #DEBUG=1
  JQDEBUG=1

  if [ "$LIGHTS" = "all" ]; then

    hue_call GET lights

  else

    local LIGHTS=$(echo "$LIGHTS" | tr "," "\n")

    for LIGHT in $LIGHTS; do
      hue_call GET lights/$LIGHT
    done

  fi
}

##
# Perform one breathe cycle.
#
# - $1 = LIGHTS
##
hue_alert() {
  local LIGHTS="$1"
  shift

  if [ "$LIGHTS" = "all" ]; then

    hue_call PUT groups/0/action '{"alert":"select"}'

  else

    local LIGHTS=$(echo "$LIGHTS" | tr "," "\n")

    for LIGHT in $LIGHTS; do
      hue_call PUT lights/$LIGHT/state '{"alert":"select"}'
    done

  fi
}

##
# Print out debug output in three modes:
#
# - normal
# - over jq
# - formatted text output (not working yet)
##
hue_output() {
  read OUTPUT

  if [ $DEBUG ]; then
    echo $OUTPUT
  fi

  if [ $JQDEBUG ]; then
    echo $OUTPUT | jq '.'
  fi
}

case "$1" in

  #
  # Set
  #

  set)
    shift
    hue_set $@
    ;;

  token)
    shift
    hue_set_token $@
    ;;

  transit)
    shift
    hue_set_transit $@
    ;;

  #
  # Scene
  #

  scene)
    shift
    hue_scene_switch $@
    ;;

  random-scene)
    shift
    hue_scene_random
    ;;

  #
  # One color scenes
  #

  one-color|oc)
    shift
    hue_scene_one_color $1
    ;;

  recipe|r)
    shift
    hue_scene_recipe $1
    ;;

  #
  # Multi color scenes
  #

  color-sequence|cs)
    shift
    hue_scene_color_sequence $@
    ;;

  random-breath|rb)
    shift
    hue_scene_random_breath $@
    ;;

  two-color-switch|tcs)
    shift
    hue_scene_two_color_switch $@
    ;;

  #
  # Info / debug
  #

  get)
    shift
    hue_get $@
    ;;

  debug)
    hue_debug
    ;;

  alert)
    shift
    hue_alert $@
    ;;

  #
  # Stop
  #

  reset)
    hue_reset
    ;;

  stop)
    hue_stop
    ;;

  kill)
    hue_kill
    ;;

  #
  # Help
  #

  help)
    hue_help
    ;;

  *)
    hue_help
    ;;

esac
