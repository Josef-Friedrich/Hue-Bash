#! /bin/bash

################################################################################
# Configuration
################################################################################

IP="192.168.2.31"

USERNAME="joseffriedrich"

INSTALLATION_PATH="/Users/jf/git-respositories/Hue-Bash"

PIDFILE="$INSTALLATION_PATH/var/run/hue.pids"

SCENES_PATH="$INSTALLATION_PATH/scenes"

DEFAULT_SCENE="random"

##
# Hue Colors
##

_RED="--hue 0"

_YELLOW="--hue 12750"

_GREEN="--hue 25500"

_WHITE="--hue 36210"

_BLUE="--hue 46920"

_CYAN="--hue 56100"

_RED2="--hue 65535"

##
# Light recipes
##

_DEFAULT="--ct 369 --bri 254"

_RELAX="--ct 443 --bri 173"

_CONCENTRATE="--ct 233 --bri 219"

_ENERGIZE="--ct 156 --bri 203"

_READING="--ct 346 --bri 240"

# Groups

_BEDROOM="1,2,3"

_LIVING="6,7,8"

################################################################################
# Options
################################################################################

while getopts ":djts" OPT; do

  case $OPT in
    d)
      DEBUG=1
      echo "debug mode" >&2
      ;;

    j)
      JQDEBUG=1
      echo "debug mode with jq" >&2
      ;;

    t)
      TEXTDEBUG=1
      echo "debug mode with text" >&2
      ;;

    s)
      JSONDEBUG=1
      echo "json debug mode" >&2
      ;;

    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;

    :)
      echo "Option -$OPTARG requires an argument." >&2
      exit 1
      ;;

  esac
done

shift $((OPTIND-1))

################################################################################
# Library functions
################################################################################

##
# Loop function.
##
function hue_loop {
  (
    while true; do
      eval "$*"
    done
  ) &
  echo $! >> $PIDFILE
}

##
# Random range function.
#
# $1 START
# $2 END
##
function hue_range {
  local START=$1
  local END=$2

  local END=$((END + 1))

  local RANGE=$((END - START))

  # $RANDOM is a number between 0 and 32767
  local BIG_RANDOM=$((RANDOM * 4 + RANDOM % 4))

  local NUMBER_IN_RANGE=$((BIG_RANDOM % RANGE))

  echo $((NUMBER_IN_RANGE + START))
}

##
# Sleep as long as transitiontime.
# TIME=$1
##
function hue_sleep {
  local TIME=$1

  # ${TIME%?}: Remove last charakter
  # ${TIME: -1}: Last charakter of a string
  sleep ${TIME%?}.${TIME: -1}
}

################################################################################
# Scenes
################################################################################

##
# Helper function for random breath scene.
##
function _hue_scene_random_breath {
  local LIGHT=$1
  local COLOR=$2
  local SPREAD=$3

  local START=$((COLOR - SPREAD))
  local END=$((COLOR + SPREAD))

  local COLOR=$(hue_range $START $END)

  # Brightness
  local BRIGHTNESS=$(hue_range 50 150)

  local TRANSTIME=$(hue_range 15 25)

  hue_set_transit $LIGHT $TRANSTIME --hue $COLOR --bri 255 --sat 255
  hue_set_transit $LIGHT $TRANSTIME --bri $BRIGHTNESS
}

##
# Scene: Random breath.
#
# - LIGHTS: comma separates lights numbers, e. g. 1,2,3,4.
# - COLOR: hue color value.
# - SPREAD:
##
function hue_scene_random_breath {

  hue_stop

  while true ; do
    case "$1" in

      -l|--lights)
        local LIGHTS=$2
        shift 2
        ;;

      -h|--hue)
        local HUE=$2
        shift 2
        ;;

      -s|--spread)
        local SPREAD=$2
        shift 2
        ;;

      *)
        break
        ;;
    esac
  done

  local LIGHTS=$(echo "$LIGHTS" | tr "," "\n")

  for LIGHT in $LIGHTS ; do
    hue_loop _hue_scene_random_breath $LIGHT $HUE $SPREAD
  done
}

################################################################################

##
# - $1: HUESEQUENCE
# - $2: SLEEPTIME
# - $3: TRANSITIONTIME
##
function _hue_scene_color_sequence {
  local HUE_SEQUENCE=$(echo $1 | tr "," "\n")

  for HUE in $HUE_SEQUENCE ; do
      hue_set all --sat 255 --hue $HUE -t $3
      hue_sleep $2
  done
}

##
#
##
function hue_scene_color_sequence {

  hue_stop

  while true ; do
    case "$1" in

      -h|--hues|--huesequence)
        local HUESEQUENCE=$2
        shift 2
        ;;

      -s|--sleeptime)
        local SLEEPTIME=$2
        shift 2
        ;;

      -t|--transitiontime)
        local TRANSITIONTIME=$2
        shift 2
        ;;

      *)
        break
        ;;
    esac
  done

  #
  # Default values.
  #
  if [ -z $HUESEQUENCE ]; then
    local HUESEQUENCE='0,10000,50000'
  fi

  if [ -z $SLEEPTIME ]; then
    local SLEEPTIME='50'
  fi

  if [ -z $TRANSITIONTIME ]; then
    local TRANSITIONTIME='5'
  fi

  hue_loop _hue_scene_color_sequence $HUESEQUENCE $SLEEPTIME $TRANSITIONTIME
}

################################################################################
# Scene functions
################################################################################

##
# Show available scenes.
##
function hue_scene_info {
  echo "Available scenes:"

  for SCENE in $(find $SCENES_PATH -name "*.scene"); do

    local TOKEN=$(echo $SCENE | sed 's:.*/\(.*\).scene:\1:')
    echo "  -> $TOKEN"

  done
}

##
# Execute scene.
##
function hue_scene_execute {
  local SCENE="$SCENES_PATH/$1.scene"

  hue_stop

  if [ -f "$SCENE" ]; then
    $SCENE
  else
    local DEFAULT_SCENE="$SCENES_PATH/$DEFAULT_SCENE.scene"

    $DEFAULT_SCENE
  fi
}

##
# Switch for scene functions.
##
function hue_scene_switch {

  case "$1" in

    execute)
      hue_scene_execute $2
      ;;

    info)
      hue_scene_info
      ;;

    stop)
      hue_stop
      ;;

    reset)
      hue_reset
      ;;

    *)
      hue_help
      ;;

  esac
}

##
# Print out a short help text.
##
function hue_help {
  echo "Usage: hue
  - help
  - set <lights> <attributes>
  - get <lights>
  - alert <lights>
  - scene
    - execute <scene>: Execute scene
    - info: Show available scenes
    - stop: Stop scene"
}

##
# Execute the http call over curl.
#
# - $1 = Http request: PUT, GET
# - $2 = path
# - $3 = json output
##
function hue_call {
  if [ -n "$3" ]; then
    local DATA="--data $3"

    if [ $JSONDEBUG ]; then
      echo $3
    fi
  fi

  curl --silent --request $1 $DATA http://$IP/api/$USERNAME/$2 | hue_output
}

##
# Stop all hue processes.
##
function hue_stop {

  for PID in $(cat $PIDFILE); do
    kill $PID > /dev/null
  done

  > $PIDFILE
}

##
# Stop all hue processes and reset to default color.
##
function hue_reset {
  hue_stop
  hue_set all $_DEFAULT
}

##
# Print out the ip adresse and the hue username.
##
function hue_debug {
  echo "IP: $IP"
  echo "USERNAME: $USERNAME"
}

##
# Process the json string.
##
function hue_process_json {

  while true ; do
    case "$1" in

      --on)
        VALUES+=("\"on\":true")
        shift 1
        ;;

      --off)
        VALUES+=("\"on\":false")
        shift 1
        ;;

      -b|--bri)
        VALUES+=("\"bri\":$2")
        shift 2
        ;;

      -h|--hue)
        VALUES+=("\"hue\":$2")
        shift 2
        ;;

      -s|--sat)
        VALUES+=("\"sat\":$2")
        shift 2
        ;;

      -x)
        local X=$2
        shift 2
        ;;

      -y)
        local Y=$2
        shift 2
        ;;

      -c|--ct)
        VALUES+=("\"ct\":$2")
        shift 2
        ;;

      -a|--alert)
        VALUES+=("\"alert\":\"$2\"")
        shift 2
        ;;

      -e|--effect)
        VALUES+=("\"effect\":\"$2\"")
        shift 2
        ;;

      -t|--transitiontime)
        VALUES+=("\"transitiontime\":$2")
        shift 2
        ;;

      *)
        break
        ;;
    esac
  done

  if [ $X ] && [ $Y ]; then
    VALUES+=("\"xy\":[$X,$Y]")
  fi

  local STATE=$(printf ",%s" "${VALUES[@]}")
  local STATE=${STATE:1}

  echo "{$STATE}"
}

##
# Set light state.
#
# $1 = Lights
# $@ = Light attributes
##
function hue_set {
  local LIGHTS="$1"
  shift

  local JSON=$(hue_process_json "$@")

  if [ "$LIGHTS" == "all" ]; then

    hue_call PUT groups/0/action $JSON

  else

    local LIGHTS=$(echo "$LIGHTS" | tr "," "\n")

    for LIGHT in $LIGHTS; do
      hue_call PUT lights/$LIGHT/state "$JSON"
    done

  fi
}

##
# Set light state with tokens.
#
# $1 = Lights
# $2 = Token
##
function hue_set_token {
  local LIGHTS="$1"
  local TOKEN="$2"

  hue_set $LIGHTS ${!TOKEN}
}

##
# Set light state with transistion time an sleep.
#
# $1 = Lights
# $2 = Transistiontime 1 = 1/10s, 10 = 1s
##
function hue_set_transit {
  local LIGHTS="$1"
  local TRANSITIONTIME="$2"
  shift 2

  hue_set $LIGHTS transitiontime $TRANSITIONTIME $@
  hue_sleep $TRANSITIONTIME
}

##
# Get the state of the lights.
#
# $1 Lights
##
function hue_get {
  local LIGHTS="$1"
  shift

  #DEBUG=1
  JQDEBUG=1

  if [ "$LIGHTS" == "all" ]; then

    hue_call GET lights

  else

    local LIGHTS=$(echo "$LIGHTS" | tr "," "\n")

    for LIGHT in $LIGHTS; do
      hue_call GET lights/$LIGHT
    done

  fi
}

##
# Perform one breathe cycle.
#
# $1 = Lights
##
function hue_alert {
  local LIGHTS="$1"
  shift

  if [ "$LIGHTS" == "all" ]; then

    hue_call PUT groups/0/action '{"alert":"select"}'

  else

    local LIGHTS=$(echo "$LIGHTS" | tr "," "\n")

    for LIGHT in $LIGHTS; do
      hue_call PUT lights/$LIGHT/state '{"alert":"select"}'
    done

  fi
}

##
# Print out debug output in three modes:
#
# - normal
# - over jq
# - formatted text output (not working yet)
##
function hue_output {
  read OUTPUT

  if [ $DEBUG ]; then
    echo $OUTPUT
  fi

  if [ $JQDEBUG ]; then
    echo $OUTPUT | jq '.'
  fi

  if [ $TEXTDEBUG ]; then

    # Hue and Saturation
    local HUE=$(echo $OUTPUT | jq '.state.hue')
    local SATURATION=$(echo $OUTPUT | jq '.state.sat')

    # XY
    local X=$(echo $OUTPUT | jq '.state.xy[0]')
    local Y=$(echo $OUTPUT | jq '.state.xy[1]')

    # COLORTEMPERATURE
    local COLORTEMPERATURE=$(echo $OUTPUT | jq '.state.ct')

    local BRIGHTNESS=$(echo $OUTPUT | jq '.state.bri')

    echo "$HUE;$SATURATION;$X;$Y;$COLORTEMPERATURE"
  fi
}

case "$1" in
  help)
    hue_help
  ;;

  set)
    shift
    hue_set $@
  ;;

  token)
    shift
    hue_set_token $@
  ;;

  transit)
    shift
    hue_set_transit $@
  ;;

  scene)
    shift
    hue_scene_switch $@
  ;;

  color-sequence)
    shift
    hue_scene_color_sequence $@
  ;;

  get)
    shift
    hue_get $@
  ;;

  alert)
    shift
    hue_alert $@
  ;;

  reset)
    hue_reset
  ;;

  stop)
    hue_stop
  ;;

  debug)
    hue_debug
  ;;

  *)
    hue_help
  ;;

esac
