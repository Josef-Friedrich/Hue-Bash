#! /bin/sh

########################################################################
# Configuration
########################################################################

IP="192.168.2.31"

USERNAME="joseffriedrich"

ALL_LIGHTS="1,2,3,7,8,9"

INSTALLATION_PATH="/root/hue"

PIDFILE="$HOME/.hue-bash_temp"

SCENES_PATH="$INSTALLATION_PATH/scenes"

DEFAULT_SCENE="random"

########################################################################
# Checks
########################################################################

if [ ! -f $PIDFILE ]; then
  touch $PIDFILE
  chmod 777 $PIDFILE
fi

########################################################################
# Options
########################################################################

while getopts ":djts" OPT; do

  case $OPT in
    d)
      DEBUG=1
      echo "debug mode" >&2
      ;;

    j)
      JQDEBUG=1
      echo "debug mode with jq" >&2
      ;;

    s)
      JSONDEBUG=1
      echo "json debug mode" >&2
      ;;

    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;

    :)
      echo "Option -$OPTARG requires an argument." >&2
      exit 1
      ;;

  esac
done

shift $((OPTIND-1))

########################################################################
# Library functions
########################################################################

##
# Loop function.
##
hue_loop() {
  (
    while true; do
      eval "$*"
    done
  ) &
  echo $! >> $PIDFILE
}

##
# Random range function.
#
# - $1 = RANGE (3:7)
##
hue_range() {
  local START=${1%%:*}
  local END=${1#*:}

  local END=$((END + 1))

  local RANGE=$((END - START))

  local RANDOM=$(tr -cd 0-9 < /dev/urandom | head -c 6)

  RANDOM="1$RANDOM"

  local NUMBER_IN_RANGE=$((RANDOM % RANGE))

  echo $((NUMBER_IN_RANGE + START))
}

########################################################################
# Scenes
########################################################################

##
# Scene: One color.
#
# - $1 = HUE
##
hue_scene_one_color() {
  hue_stop
  hue_set all --hue $1 --sat 255 --bri 255
}

##
# Scene: Default color.
##
hue_scene_default_color() {

  hue_stop

  while true ; do
    case "$1" in

      -b|--blue)
        hue_set all --hue 46920 --bri 255 --sat 255
        break
        ;;

      -c|--cyan)
        hue_set all --hue 56100 --bri 255 --sat 255
        break
        ;;

      -g|--green)
        hue_set all --hue 25500 --bri 255 --sat 255
        break
        ;;

      -r|--red)
        hue_set all --hue 0 --bri 255 --sat 255
        break
        ;;

      -w|--white)
        hue_set all --hue 36210 --bri 255 --sat 255
        break
        ;;

      -y|--yellow)
        hue_set all --hue 12750 --bri 255 --sat 255
        break
        ;;

      *)
        break
        ;;

    esac
  done

}

########################################################################

##
# Scene: Recipe
#
# - $1 = RECIPE
##
hue_scene_recipe() {

  hue_stop

  while true ; do
    case "$1" in

      -c|--concentrate)
        hue_set all --ct 233 --bri 219
        break
        ;;

      -d|--default)
        hue_set all --ct 369 --bri 254
        break
        ;;

      -e|--energize)
        hue_set all --ct 156 --bri 203
        break
        ;;

      -h|--help)
        hue_scene_recipe_help
        break
        ;;

      -R|--reading)
        hue_set all --ct 346 --bri 240
        break
        ;;

      -r|--relax)
        hue_set all --ct 443 --bri 173
        break
        ;;

      *)
        hue_scene_recipe_help
        break
        ;;

    esac
  done
}

hue_scene_recipe_help() {
  echo "Usage: hue recipe <option>

DESCRIPTION
        This scene command shows white colors in different color
        temperatures. All lights displaying the same color temperature.

OPTIONS (only one option is possible)
        -c, --concentrate
                This option creates a light situation best for
                concentrating. It show a medium cold color temperature.

        -d, --default
                Show the default white color temperature, which the
                lights showing, when they turned on.

        -e, --energize
                The option 'energize' produces the coldest white color
                of all recipes.

        -h, --help
                Show this help text.

        -R, --reading
                The hue lights displaying a medium warm white color
                temperature, which is good for reading.

        -r, --relax
                Let the hue lights shine in a very warm white color,
                which is optimized for relaxing.

SORTING BY COLOR TEMPERATURE
        COLD -> energize (156) -> concentrate (233) -> readintg (346)
        -> default (369) -> relax (443) -> WARM

        The numbers in parentheses are Mired color temperature values.6)
        -> default (369) -> relax (443) -> WARM

EXAMPLES
        hue recipe --reading
        hue recipe -r
"
}

########################################################################

##
# Scene: Random breath.
##
hue_scene_random_breath() {

  hue_stop

  while true ; do
    case "$1" in

      -l|--lights)
        local LIGHTS=$2
        shift 2
        ;;

      -h|--hue-range)
        local HUE_RANGE=$2
        shift 2
        ;;

      -t|--time-range)
        local TIME_RANGE=$2
        shift 2
        ;;

      -b|--bri-range|--brightness-range)
        local BRI_RANGE=$2
        shift 2
        ;;

      *)
        break
        ;;
    esac
  done

  #
  # Default JSON.
  #
  if [ -z $LIGHTS ]; then

    if [ -n $ALL_LIGHTS ]; then
      LIGHTS=$ALL_LIGHTS
    else
      echo "Usage: hue random-breath --lights 1,2,3 --hue-range 52000:58000 --time-range 5:15 --brightness-range 50:150"
      exit 1
    fi
  fi

  if [ -z $HUE_RANGE ]; then
    local HUE_RANGE='52000:58000'
  fi

  if [ -z $TIME_RANGE ]; then
    local TIME_RANGE='2:4'
  fi

  if [ -z $BRI_RANGE ]; then
    local BRI_RANGE='50:255'
  fi

  OLD_IFS=$IFS; IFS=","

  for LIGHT in $LIGHTS ; do
    IFS=$OLD_IFS

    hue_loop _hue_scene_random_breath $LIGHT $HUE_RANGE $TIME_RANGE $BRI_RANGE
  done

}

##
# Helper function for random breath scene.
#
# - $1 = LIGHT
# - $2 = HUE_RANGE
# - $3 = TIME_RANGE
# - $4 = BRI_RANGE
##
_hue_scene_random_breath() {
  local TRANSTIME=$(hue_range $3)
  local BRI_START=${4%%:*}
  local BRI_END=${4#*:}

  hue_set_transit $1 $TRANSTIME --hue $(hue_range $2) --bri $BRI_END --sat 255
  hue_set_transit $1 $TRANSTIME --bri $BRI_START
}

########################################################################

##
# Scene: All lights change at the same time the color in a given sequence.
##
hue_scene_color_sequence() {

  hue_stop

  while true ; do
    case "$1" in

      -h|--hues|--huesequence)
        local HUE_SEQUENCE=$2
        shift 2
        ;;

      -s|--sleeptime)
        local SLEEP_TIME=$2
        shift 2
        ;;

      -t|--transitiontime)
        local TRANSITION_TIME=$2
        shift 2
        ;;

      -b|--bri|--brightness)
        local BRIGHTNESS=$2
        shift 2
        ;;

      *)
        break
        ;;
    esac
  done

  #
  # Default JSON.
  #
  if [ -z $HUE_SEQUENCE ]; then
    local HUE_SEQUENCE='0,12750,25500,46920,56100'
  fi

  if [ -z $SLEEP_TIME ]; then
    local SLEEP_TIME='5'
  fi

  if [ -z $TRANSITION_TIME ]; then
    local TRANSITION_TIME='1'
  fi

  if [ -z $BRIGHTNESS ]; then
    local BRIGHTNESS='255'
  fi

  hue_loop _hue_scene_color_sequence $HUE_SEQUENCE $SLEEP_TIME $TRANSITION_TIME $BRIGHTNESS
}

##
# - $1 = HUE_SEQUENCE
# - $2 = SLEEP_TIME
# - $3 = TRANSITION_TIME
# - $4 = BRIGHTNESS
##
_hue_scene_color_sequence() {
  HUE_SEQUENCE=$1

  OLD_IFS=$IFS; IFS=","

  for HUE in $HUE_SEQUENCE ; do
    IFS=$OLD_IFS

    hue_set all --sat 255 --hue $HUE -t $(($3 * 10)) --bri $4
    sleep $2
  done
}

########################################################################

##
# Scene: Switch between two colors.
##
hue_scene_two_color_switch() {

  hue_stop

  while true ; do
    case "$1" in

      -l1|--lights1)
        local LIGHTS1=$2
        shift 2
        ;;

      -l2|--lights2)
        local LIGHTS2=$2
        shift 2
        ;;

      -c1|color1)
        local COLOR1=$2
        shift 2
        ;;

      -c2|color2)
        local COLOR2=$2
        shift 2
        ;;

      -s|switchtime)
        local SWITCH_TIME=$2
        shift 2
        ;;

      *)
        break
        ;;
    esac
  done

  #
  # Default JSON.
  #
  if [ -z $LIGHTS1 ] || [ -z $LIGHTS2 ] ; then
    echo "Usage: hue two-color-switch --lights1 1,2 --lights2 3,4"
    exit 1
  fi

  if [ -z $COLOR1 ]; then
    local COLOR1='0'
  fi

  if [ -z $COLOR2 ]; then
    local COLOR2='46920'
  fi

  if [ -z $SWITCH_TIME ]; then
    local SWITCH_TIME='2'
  fi

  hue_set all --sat 255 --bri 255

  hue_loop _hue_scene_two_color_switch $LIGHTS1 $LIGHTS2 $COLOR1 $COLOR2 $SWITCH_TIME
}

##
# - 1$ = LIGHTS1
# - 2$ = LIGHTS2
# - 3$ = COLOR1
# - 4$ = COLOR2
# - 5$ = SWITCH_TIME
##
_hue_scene_two_color_switch() {

  hue_set $1 --hue $3 -t 5
  hue_set $2 --hue $4 -t 5
  sleep $5

  hue_set $2 --hue $3 -t 5
  hue_set $1 --hue $4 -t 5
  sleep $5
}

########################################################################
# Scene functions
########################################################################

_hue_scene_get_random() {
  cat $INSTALLATION_PATH/random-scenes.conf | grep -v '^$' | grep -v '#' | sort -R | head -n 1
}

hue_scene_random() {
  hue_stop
  eval $(_hue_scene_get_random)
}

##
# Show available scenes.
##
hue_scene_info() {
  echo "Available scenes:"

  for SCENE in $(find $SCENES_PATH -name "*.scene"); do

    local TOKEN=$(echo $SCENE | sed 's:.*/\(.*\).scene:\1:')
    echo "  -> $TOKEN"

  done
}

##
# Execute scene.
#
# - $1 = SCENE_TOKEN
##
hue_scene_execute() {
  local SCENE="$SCENES_PATH/$1.scene"

  hue_stop

  if [ -f "$SCENE" ]; then
    $SCENE
  else
    local DEFAULT_SCENE="$SCENES_PATH/$DEFAULT_SCENE.scene"

    $DEFAULT_SCENE
  fi
}

##
# Switch for scene functions.
##
hue_scene_switch() {

  case "$1" in

    execute)
      hue_scene_execute $2
      ;;

    info)
      hue_scene_info
      ;;

    stop)
      hue_stop
      ;;

    reset)
      hue_reset
      ;;

    *)
      hue_help
      ;;

  esac
}

##
# Print out a short help text.
##
hue_help_short() {
  echo "Usage: hue <command>
  help
  set <lights> <attributes>
  get <lights>
  alert <lights>
  scene
    execute <scene>: Execute scene
    info: Show available scenes
    stop: Stop scene

One color scenes:

  one-color
  recipe

Multi color scenes:

  color-sequence
  random-breath
  two-color-switch

 "
}

hue_help_long() {

  echo "
Warning! Experimental code!

NAME
        hue - control the Hue lights from Philips using a minimal unix
        shell.

SYNOPSIS
        hue <command> <options>

DESCRIPTION
        Hue-Shell is a shell script to control the Hue lamps from
        Philips (https://www.meethue.com).

REQUIREMENTS
        curl

INSTALLATION
        You need a working Philips Hue setup, the IP address of your
        bridge and a username to access the bridge. Please read
        http://developers.meethue.com/gettingstarted.html for more
        informations to achieve that. Than edit the file 'hue' and fill
        in the values for IP and USERNAME.


"
  hue_help_heading1 "HUE SET"

  hue_set_help

  hue_help_heading1 "HUE RECIPE"

  hue_scene_recipe_help

}

##
# Generate ASCII decoration for help headings.
#
# - $@ = Heading text
##
hue_help_heading1() {
  echo "########################################################################
# $@
########################################################################
"

}

##
# Generate ASCII decoration for help headings.
#
# - $@ = Heading text
##
hue_help_heading2() {
  echo "##
# $@
##
"
}

##
# Execute the http call over curl.
#
# - $1 = HTTP_REQUEST: PUT, GET
# - $2 = PATH:
# - $3 = JSON:
##
hue_call() {
  if [ -n "$3" ]; then
    local DATA="--data $3"

    if [ $JSONDEBUG ]; then
      echo $3
    fi
  fi

  curl --silent --request $1 $DATA http://$IP/api/$USERNAME/$2 | hue_output
}

##
# Stop all hue processes.
##
hue_stop() {

  for PID in $(cat $PIDFILE); do
    kill $PID > /dev/null 2>&1
  done

  > $PIDFILE
}

##
# Kill all hue process.
#
# Goal of this function is to kill all process (background,
# other terminals.)
##
hue_kill() {
  hue_reset

  # Alternatives:
  # - pkill (not on openwrt, busybox)
  # - ps -w | grep "hue" | awk '{print $1}'

  killall hue
}

##
# Stop all hue processes and reset to default color.
##
hue_reset() {
  hue_stop
  hue_set all --ct 369 --bri 254
}

##
# Set light state.
#
# - $1 = LIGHTS
# - $@ = LIGHT_ATTRIBUTES
##
hue_set() {
  local LIGHTS="$1"
  shift

  local JSON=""

  while true ; do
    case "$1" in

      --on)
        JSON="$JSON,\"on\":true"
        shift 1
        ;;

      --off)
        JSON="$JSON,\"on\":false"
        shift 1
        ;;

      -b|--bri|--brightness)
        JSON="$JSON,\"bri\":$2"
        shift 2
        ;;

      -h|--hue)
        JSON="$JSON,\"hue\":$2"
        shift 2
        ;;

      -s|--sat|--saturation)
        JSON="$JSON,\"sat\":$2"
        shift 2
        ;;

      -x)
        local X=$2
        shift 2
        ;;

      -y)
        local Y=$2
        shift 2
        ;;

      -c|--ct)
        JSON="$JSON,\"ct\":$2"
        shift 2
        ;;

      -a|--alert)
        JSON="$JSON,\"alert\":\"$2\""
        shift 2
        ;;

      -e|--effect)
        JSON="$JSON,\"effect\":\"$2\""
        shift 2
        ;;

      -t|--transitiontime)
        JSON="$JSON,\"transitiontime\":$2"
        shift 2
        ;;

      -H|--help)
        hue_set_help
        break
        ;;

      *)
        if [ -n "$1" ]; then
          hue_set_help
        fi
        break
        ;;
    esac
  done

  if [ $X ] && [ $Y ]; then
    JSON="$JSON,\"xy\":[$X,$Y]"
  fi

  JSON=$(echo -n $JSON | tail -c +2)

  JSON="{$JSON}"

  if [ "$LIGHTS" = "all" ]; then

    hue_call PUT groups/0/action $JSON

  else

    OLD_IFS=$IFS; IFS=","

    for LIGHT in $LIGHTS; do
      IFS=$OLD_IFS

      hue_call PUT lights/$LIGHT/state "$JSON"
    done

  fi
}

hue_set_help() {
  echo "Usage: hue set <lights> <options>

OPTIONS

        --on
                On state of the light.

        --off
                Off state of the light.

        -b, --bri, --brightness
                The brightness value to set the light to. Brightness is
                a scale from 0 (the minimum the light is capable of) to
                255 (the maximum). Note: a brightness of 0 is not off.

        -h, --hue
                The hue value to set light to. The hue value is a
                wrapping value between 0 and 65535. Both 0 and 65535 are
                red, 25500 is green and 46920 is blue.

        -H, --help
                Show this help text.

        -s, --sat, --saturation
                Saturation of the light. 255 is the most saturated
                (colored) and 0 is the least saturated (white).

        -x
                The x coordinates in CIE color space.

        -y
                The y coordinates in CIE color space.

                Both x and y must be between 0 and 1. If the specified
                coordinates are not in the CIE color space, the closest
                color to the coordinates will be chosen.

        -c, --ct
                The Mired Color temperature of the light. 2012 connected
                lights are capable of 153 (6500K) to 500 (2000K).

        -a, --alert
                The alert effect, is a temporary change to the bulb’s
                state, and has one of the following values:
                  “none” – The light is not performing an alert effect.
                  “select” – The light is performing one breathe cycle.
                  “lselect” – The light is performing breathe cycles for
                  30 seconds or until an “none” command is received.

        -e, --effect
                The dynamic effect of the light. Currently “none” and
                “colorloop” are supported. Other values will generate an
                error of type 7.
                Setting the effect to colorloop will cycle through all
                hues using the current brightness and saturation
                settings.

        -t, --transitiontime
                The duration of the transition from the light’s current
                state to the new state. This is given as a multiple of
                100ms and defaults to 4 (400ms).

EXAMPLES
        hue set 1,2,3 --alert
        hue set all --hue 23456 --bri 123 --sat 234
"
}

##
# Set light state with tokens.
#
# - $1 = LIGHTS
# - $2 = TOKEN
##
hue_set_token() {
  local LIGHTS="$1"
  local TOKEN="$2"

  hue_set $LIGHTS $TOKEN
}

##
# Set light state with transistion time an sleep.
#
# $1 = LIGHTS:
# $2 = TRANSITIONTIME: in seconds
##
hue_set_transit() {
  local LIGHTS="$1"
  local TRANSITIONTIME="$2"
  shift 2

  hue_set $LIGHTS --transitiontime $(($TRANSITIONTIME * 10)) $@
  sleep $TRANSITIONTIME
}

##
# Get the state of the lights.
#
# - $1 = LIGHTS
##
hue_get() {
  local LIGHTS="$1"
  shift

  DEBUG=1
  #JQDEBUG=1

  if [ "$LIGHTS" = "all" ]; then

    hue_call GET lights

  else

    OLD_IFS=$IFS; IFS=","

    for LIGHT in $LIGHTS; do
      IFS=$OLD_IFS

      hue_call GET lights/$LIGHT
    done

  fi
}

##
# Perform one breathe cycle.
#
# - $1 = LIGHTS
##
hue_alert() {
  local LIGHTS="$1"
  shift

  if [ "$LIGHTS" = "all" ]; then

    hue_call PUT groups/0/action '{"alert":"select"}'

  else

    OLD_IFS=$IFS; IFS=","

    for LIGHT in $LIGHTS; do
      IFS=$OLD_IFS

      hue_call PUT lights/$LIGHT/state '{"alert":"select"}'
    done

  fi
}

##
# Print out debug output in three modes:
#
# - normal
# - over jq
# - formatted text output (not working yet)
##
hue_output() {
  read OUTPUT

  if [ $DEBUG ]; then
    echo $OUTPUT
  fi

  if [ $JQDEBUG ]; then
    echo $OUTPUT | jq '.'
  fi
}

case "$1" in

  #
  # Set
  #

  set)
    shift
    hue_set $@
    ;;

  token)
    shift
    hue_set_token $@
    ;;

  transit)
    shift
    hue_set_transit $@
    ;;

  #
  # Scene
  #

  scene)
    shift
    hue_scene_switch $@
    ;;

  random-scene)
    shift
    hue_scene_random
    ;;

  #
  # One color scenes
  #

  default-color|dc)
    shift
    hue_scene_default_color $1
    ;;

  one-color|oc)
    shift
    hue_scene_one_color $1
    ;;

  recipe|r)
    shift
    hue_scene_recipe $1
    ;;

  #
  # Multi color scenes
  #

  color-sequence|cs)
    shift
    hue_scene_color_sequence $@
    ;;

  random-breath|rb)
    shift
    hue_scene_random_breath $@
    ;;

  two-color-switch|tcs)
    shift
    hue_scene_two_color_switch $@
    ;;

  #
  # Info / debug
  #

  get)
    shift
    hue_get $@
    ;;

  alert)
    shift
    hue_alert $@
    ;;

  #
  # Stop
  #

  reset)
    hue_reset
    ;;

  stop)
    hue_stop
    ;;

  kill)
    hue_kill
    ;;

  #
  # Help
  #

  help)
    hue_help_long
    ;;

  *)
    hue_help_short
    ;;

esac
