#! /bin/bash

################################################################################
# Configuration
################################################################################

IP="192.168.2.31"

USERNAME="joseffriedrich"

INSTALLATION_PATH="/Users/jf/git-respositories/Hue-Bash"

PIDFILE="$INSTALLATION_PATH/var/run/hue.pids"

SCENES_PATH="$INSTALLATION_PATH/scenes"

DEFAULT_SCENE="random"

##
# Hue Colors
##

_RED="hue 0"

_YELLOW="hue 12750"

_GREEN="hue 25500"

_WHITE="hue 36210"

_BLUE="hue 46920"

_CYAN="hue 56100"

_RED2="hue 65535"

##
# Light recipes
##

_DEFAULT="ct 369 bri 254"

_RELAX="ct 443 bri 173"

_CONCENTRATE="ct 233 bri 219"

_ENERGIZE="ct 156 bri 203"

_READING="ct 346 bri 240"

# Groups

_BEDROOM="1,2,3"

_LIVING="6,7,8"

################################################################################
# Options
################################################################################

while getopts ":djts" OPT; do

  case $OPT in
    d)
      DEBUG=1
      echo "debug mode" >&2
      ;;

    j)
      JQDEBUG=1
      echo "debug mode with jq" >&2
      ;;

    t)
      TEXTDEBUG=1
      echo "debug mode with text" >&2
      ;;

    s)
      JSONDEBUG=1
      echo "json debug mode" >&2
      ;;

    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;

    :)
      echo "Option -$OPTARG requires an argument." >&2
      exit 1
      ;;

  esac
done

shift $((OPTIND-1))

################################################################################
# Library functions
################################################################################

##
# Loop function.
##
function hue_loop {
  (
    while true; do
      eval "$*"
    done
  ) &
  echo $! >> $PIDFILE
}

##
# Random range function.
#
# $1 START
# $2 END
##
function hue_range {
  START=$1
  END=$2

  END=$((END + 1))

  RANGE=$((END - START))

  # $RANDOM is a number between 0 and 32767
  BIG_RANDOM=$((RANDOM * 4 + RANDOM % 4))

  NUMBER_IN_RANGE=$((BIG_RANDOM % RANGE))

  echo $((NUMBER_IN_RANGE + START))
}

##
# Sleep as long as transitiontime.
# TIME=$1
##
function hue_sleep {
  TIME=$1

  # ${TIME%?}: Remove last charakter
  # ${TIME: -1}: Last charakter of a string
  sleep ${TIME%?}.${TIME: -1}
}

################################################################################
# Scene functions
################################################################################

##
# Show available scenes.
##
function hue_scene_info {
  echo "Available scenes:"

  for SCENE in $(find $SCENES_PATH -name "*.scene"); do

    TOKEN=$(echo $SCENE | sed 's:.*/\(.*\).scene:\1:')
    echo "  -> $TOKEN"

  done
}

##
# Execute scene.
##
function hue_scene_execute {
  SCENE="$SCENES_PATH/$1.scene"

  hue_stop

  if [ -f "$SCENE" ]; then
    $SCENE
  else
    DEFAULT_SCENE="$SCENES_PATH/$DEFAULT_SCENE.scene"

    $DEFAULT_SCENE
  fi
}

##
# Switch for scene functions.
##
function hue_scene_switch {

  case "$1" in



    execute)
      hue_scene_execute $2
      ;;

    info)
      hue_scene_info
      ;;

    stop)
      hue_stop
      ;;

    reset)
      hue_reset
      ;;

    *)
      hue_help
      ;;

  esac
}

##
# Print out a short help text.
##
function hue_help {
  echo "Usage: hue
  - help
  - set <lights> <attributes>
  - get <lights>
  - alert <lights>
  - scene
    - execute <scene>: Execute scene
    - info: Show available scenes
    - stop: Stop scene"
}

##
# Execute the http call over curl.
#
# - $1 = Http request: PUT, GET
# - $2 = path
# - $3 = json output
##
function hue_call {
  if [ -n "$3" ]; then
    DATA="--data $3"

    if [ $JSONDEBUG ]; then
      echo $3
    fi
  fi

  curl --silent --request $1 $DATA http://$IP/api/$USERNAME/$2 | hue_output
}

##
# Stop all hue processes.
##
function hue_stop {

  for PID in $(cat $PIDFILE); do
    kill $PID > /dev/null
  done

  > $PIDFILE
}

##
# Stop all hue processes and reset to default color.
##
function hue_reset {
  hue_stop
  hue_set all $_DEFAULT
}

##
# Print out the ip adresse and the hue username.
##
function hue_debug {
  echo "IP: $IP"
  echo "USERNAME: $USERNAME"
}

##
# Process the json string.
##
function hue_process_json {

  while true ; do
    case "$1" in

      on)
        VALUES+=("\"on\":true")
        shift 1
        ;;

      off)
        VALUES+=("\"on\":false")
        shift 1
        ;;

      b|bri)
        VALUES+=("\"bri\":$2")
        shift 2
        ;;

      h|hue)
        VALUES+=("\"hue\":$2")
        shift 2
        ;;

      s|sat)
        VALUES+=("\"sat\":$2")
        shift 2
        ;;

      x)
        X=$2
        shift 2
        ;;

      y)
        Y=$2
        shift 2
        ;;

      c|ct)
        VALUES+=("\"ct\":$2")
        shift 2
        ;;

      a|alert)
        VALUES+=("\"alert\":\"$2\"")
        shift 2
        ;;

      e|effect)
        VALUES+=("\"effect\":\"$2\"")
        shift 2
        ;;

      t|transitiontime)
        VALUES+=("\"transitiontime\":$2")
        shift 2
        ;;

      *)
        break
        ;;
    esac
  done

  if [ $X ] && [ $Y ]; then
    VALUES+=("\"xy\":[$X,$Y]")
  fi

  STATE=$(printf ",%s" "${VALUES[@]}")
  STATE=${STATE:1}

  echo "{$STATE}"
}

##
# Set light state.
#
# $1 = Lights
# $@ = Light attributes
##
function hue_set {
  LIGHTS="$1"
  shift

  JSON=$(hue_process_json "$@")

  if [ "$LIGHTS" == "all" ]; then

    hue_call PUT groups/0/action $JSON

  else

    LIGHTS=$(echo "$LIGHTS" | tr "," "\n")

    for LIGHT in $LIGHTS; do
      hue_call PUT lights/$LIGHT/state "$JSON"
    done

  fi
}

##
# Set light state with tokens.
#
# $1 = Lights
# $2 = Token
##
function hue_set_token {
  LIGHTS="$1"
  TOKEN="$2"

  hue_set $LIGHTS ${!TOKEN}
}

##
# Get the state of the lights.
#
# $1 Lights
##
function hue_get {
  LIGHTS="$1"
  shift

  #DEBUG=1
  JQDEBUG=1

  if [ "$LIGHTS" == "all" ]; then

    hue_call GET lights

  else

    LIGHTS=$(echo "$LIGHTS" | tr "," "\n")

    for LIGHT in $LIGHTS; do
      hue_call GET lights/$LIGHT
    done

  fi
}

##
# Perform one breathe cycle.
#
# $1 = Lights
##
function hue_alert {
  LIGHTS="$1"
  shift

  if [ "$LIGHTS" == "all" ]; then

    hue_call PUT groups/0/action '{"alert":"select"}'

  else

    LIGHTS=$(echo "$LIGHTS" | tr "," "\n")

    for LIGHT in $LIGHTS; do
      hue_call PUT lights/$LIGHT/state '{"alert":"select"}'
    done

  fi
}

##
# Print out debug output in three modes:
#
# - normal
# - over jq
# - formatted text output (not working yet)
##
function hue_output {
  read OUTPUT

  if [ $DEBUG ]; then
    echo $OUTPUT
  fi

  if [ $JQDEBUG ]; then
    echo $OUTPUT | jq '.'
  fi

  if [ $TEXTDEBUG ]; then

    # Hue and Saturation
    HUE=$(echo $OUTPUT | jq '.state.hue')
    SATURATION=$(echo $OUTPUT | jq '.state.sat')

    # XY
    X=$(echo $OUTPUT | jq '.state.xy[0]')
    Y=$(echo $OUTPUT | jq '.state.xy[1]')

    # COLORTEMPERATURE
    COLORTEMPERATURE=$(echo $OUTPUT | jq '.state.ct')

    BRIGHTNESS=$(echo $OUTPUT | jq '.state.bri')

    echo "$HUE;$SATURATION;$X;$Y;$COLORTEMPERATURE"
  fi
}

case "$1" in
  help)
    hue_help
  ;;

  set)
    shift
    hue_set $@
  ;;

  scene)
    shift
    hue_scene_switch $@
  ;;

  token)
    shift
    hue_set_token $@
  ;;

  get)
    shift
    hue_get $@
  ;;

  alert)
    shift
    hue_alert $@
  ;;

  reset)
    hue_reset
  ;;

  stop)
    hue_stop
  ;;

  debug)
    hue_debug
  ;;

  *)
    hue_help
  ;;

esac
